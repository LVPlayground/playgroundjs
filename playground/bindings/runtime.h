// Copyright 2015 Las Venturas Playground. All rights reserved.
// Use of this source code is governed by the MIT license, a copy of which can
// be found in the LICENSE file.

#ifndef PLAYGROUND_BINDINGS_RUNTIME_H_
#define PLAYGROUND_BINDINGS_RUNTIME_H_

#include <memory>
#include <string>

#include <include/v8.h>

#include "base/file_path.h"

namespace bindings {

class GlobalScope;
struct RuntimeOptions;

// The runtime class represents a v8 virtual machine. It establishes and maintains the VM and
// provides the ability to execute scripts or callbacks on it.
class Runtime {
 public:
  // The delegate enables the runtime to communicate with its embedder for the purposes of passing
  // forward output that has been generated by the JavaScript engine.
  class Delegate {
   public:
    virtual void OnScriptOutput(const std::string& message) = 0;
    virtual void OnScriptError(const std::string& filename, size_t line_number, const std::string& message) = 0;

   protected:
    virtual ~Delegate() {}
  };

  Runtime(const RuntimeOptions& options,
          const base::FilePath& script_directory,
          Delegate* runtime_delegate);
  ~Runtime();

  // Initializes the runtime by installing all prototypes and objects. The list of prototypes must
  // have been completed at the time of this call.
  void Initialize();

  // Tears down parts of the runtime that have to be destroyed before other parts.
  void Dispose();

  // Encapsulates both the source-code of a script and the origin filename.
  struct ScriptSource {
    ScriptSource() = default;
    ScriptSource(const std::string& source)
        : source(source) {}

    std::string source;
    std::string filename;
  };

  // Defines how to execute a script passed to |Execute| or |ExecuteFile|. Execution as a module
  // will surround the script in module boilerplate code, for use with require().
  enum ExecutionType {
    EXECUTION_TYPE_NORMAL,
    EXECUTION_TYPE_MODULE
  };

  // Executes |script_source| using the runtime. May be called multiple times in the lifetime of
  // this runtime. The same global object will be reused for each invocation. The caller must
  // have created a handle scope prior to using this method.
  bool Execute(const ScriptSource& script_source,
               v8::Local<v8::Value>* result = nullptr);

  // Executes |file| using the runtime. The file will be read from disk before it will be executed.
  // The caller must have created a handle scope prior to using this method.
  bool ExecuteFile(const base::FilePath& file,
                   ExecutionType execution_type,
                   v8::Local<v8::Value>* result = nullptr);

  // To be called on every frame of the server.
  void OnFrame();

  // Calls |function| with |arguments| in a safe manner. Exceptions will be logged, but will not
  // terminate either current execution or the script as a whole.
  bool Call(v8::Local<v8::Function> function,
            size_t argument_count,
            v8::Local<v8::Value> arguments[]);

  // Returns the isolate associated with this runtime.
  v8::Isolate* isolate() const { return isolate_; }

  // Returns the context associated with this runtime.
  v8::Local<v8::Context> context() const { return context_.Get(isolate_); }

  // Returns the global scope instance, allowing external users to install additional objects.
  GlobalScope* global_scope() { return global_scope_.get(); }

  // Returns the delegate for this runtime. May be a nullptr.
  Delegate* delegate() { return runtime_delegate_; }

 private:
  // Dispatches the exception caught in |try_catch| to the delegate, if any.
  void DisplayException(const v8::TryCatch& try_catch);

  base::FilePath script_directory_;
  Delegate* runtime_delegate_;
  std::string frame_event_name_;

  std::unique_ptr<v8::Platform> platform_;
  std::unique_ptr<v8::ArrayBuffer::Allocator> allocator_;

  // Memory for the isolate is owned by V8.
  v8::Isolate* isolate_;

  // This plugin uses a single isolate, so maintain a global isolate scope.
  std::unique_ptr<v8::Isolate::Scope> isolate_scope_;

  // The context used by the plugin. There will only be one.
  v8::Persistent<v8::Context> context_;

  // The global scope that will service the runtime.
  std::unique_ptr<GlobalScope> global_scope_;
};

}  // namespace

#endif  // PLAYGROUND_BINDINGS_RUNTIME_H_
